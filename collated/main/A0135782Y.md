# A0135782Y
###### \java\seedu\taskmaster\logic\commands\AddFloatingCommand.java
``` java
/**
 * Adds a floating task to the task list.
 */
public class AddFloatingCommand extends AddCommand {
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a floating task to the task list. "
            + "Parameters: TASK_NAME [t/TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " take trash t/highPriority";

    public static final String MESSAGE_SUCCESS = "New floating task added: %1$s";
    private final Task toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddFloatingCommand(String name, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(new Name(name), new UniqueTagList(tagSet));
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            CommandResult result = new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
            int targetIndex = model.getFilteredTaskComponentList().size();
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - INDEX_OFFSET));
            return result;
        } catch (UniqueTaskList.DuplicateTaskException e) {
        	indicateAttemptToExecuteFailedCommand();
        	urManager.popFromUndoQueue();
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TimeslotOverlapException e) {
			assert false: "not possible";
        	return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
		}
    }
}
```
###### \java\seedu\taskmaster\logic\commands\AddNonFloatingCommand.java
``` java
/**
 * Adds a non floating task to the task list
 */
public class AddNonFloatingCommand extends AddCommand {
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a non floating task to the task list. "
            + "Parameters: TASK_NAME from START_DATE to END_DATE [RECURRING_TYPE] [repeat RECURRING_PERIOD] [t/TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " do homework from 2 oct 2am to 3 oct 3am daily t/highPriority";

    public static final String MESSAGE_SUCCESS = "New non-floating task added: %1$s";
    public static final String MESSAGE_TIMESLOT_OCCUPIED = "This timeslot is already blocked or overlapped with existing tasks.";
    public static final String MESSAGE_ILLEGAL_TIME_SLOT = "End time must be later than Start time.";
    
    private final Task toAdd;

    /**
     * Convenience constructor using raw values.
     * @param recurringType 
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddNonFloatingCommand(String name, Set<String> tags, TaskDate startDate, TaskDate endDate,
           RecurringType recurringType, int recurringPeriod) throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(name, tags, startDate, endDate, recurringType);
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(new Name(name), new UniqueTagList(tagSet),
                              new TaskDate(startDate), new TaskDate(endDate),
                              recurringType, recurringPeriod);
        if (!this.toAdd.getLastAppendedComponent().isValidNonFloatingTime()) {
        	indicateAttemptToExecuteIncorrectCommand();
        	throw new IllegalValueException(MESSAGE_ILLEGAL_TIME_SLOT);
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            CommandResult result = new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
            int targetIndex = model.getFilteredTaskComponentList().size();
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - INDEX_OFFSET));
            return result;
        } catch (UniqueTaskList.DuplicateTaskException e) {
        	indicateAttemptToExecuteFailedCommand();
        	urManager.popFromUndoQueue();
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TimeslotOverlapException e) {
        	indicateAttemptToExecuteFailedCommand();
        	urManager.popFromUndoQueue();
        	return new CommandResult(MESSAGE_TIMESLOT_OCCUPIED);
		}
    }
}
```
###### \java\seedu\taskmaster\logic\parser\DateParser.java
``` java
/**
 * Parses the recurring info to determine the recurring type of the input.
 * DateParser is a singleton, use getInstance() to gain access to this class.
 */
public class DateParser {
    private static final int FIRST_PARSED_DATE = 0;

    private static DateParser instance;
    
    private HashSet<RecurringType> recurringTypes;
    private static final com.joestelmach.natty.Parser nattyParser = new com.joestelmach.natty.Parser();
    
    private DateParser() {
        populateSupportedRecurringTypes();
    }

    /**
     * Populate the recurringTypes with what is in RecurringType enum.
     */
    private void populateSupportedRecurringTypes() {
        recurringTypes = new HashSet<RecurringType>();
        for (RecurringType t : RecurringType.values()) {
            recurringTypes.add(t);
        }
        recurringTypes.remove(RecurringType.IGNORED);
    }
    
    /**
     * Obtain the recurring type using a string
     * 
     * @param input The recurring type in formatted String form.
     * @return The recurring type in enum form.
     * @throws IllegalArgumentException If the string is not the same as the RecurringType value
     */
    private RecurringType getRecurringType(String input) throws IllegalArgumentException {
        if (recurringTypes.contains(RecurringType.valueOf(input))) {
            return RecurringType.valueOf(input);
        }
        return RecurringType.IGNORED;
    }
    
    /**
     * Extracts the recurring type from a unformatted string.
     * Formats the string to extract out the recurring type.
     * 
     * @param recurringInfo The recurring type in unformatted string String form.
     * @return The recurring type in enum form.
     * @throws IllegalArgumentException If the string is not the same as the RecurringType value
     */
    public RecurringType extractRecurringInfo(String recurringInfo) throws IllegalArgumentException {
        recurringInfo = recurringInfo.toUpperCase().trim();
        return getRecurringType(recurringInfo);
    }
    
    /**
     * Parses through the dateInput and provides the Date from that input
     * 
     * @param dateInput
     *            The date that we want to convert from string to Date
     * @return A single Date from the string
     * @throws IllegalValueException 
     */
    public Date getDateFromString(String dateInput) throws IllegalValueException {
        List<DateGroup> dateGroups = nattyParser.parse(dateInput);
        try {
            return dateGroups.get(FIRST_PARSED_DATE).getDates().get(FIRST_PARSED_DATE);
        } catch (Exception e) {
            throw new IllegalValueException(MESSAGE_ILLEGAL_DATE_INPUT);
        }
    }
    
    /**
     * Obtains date group list for add XXXX from XXXX to XXXX
     * Helps to allow greater flexibility in the command.
     * 
     * @param dateInput The command for adding non floating task.
     * @return The date group list using natty.
     * @throws IllegalValueException If the input does not yield any date group.
     */
    public List<Date> getFromToDatesFromString(String dateInput) throws IllegalValueException {
        List<DateGroup> dateGroups = nattyParser.parse(dateInput);
        try {
            return dateGroups.get(FIRST_PARSED_DATE).getDates();
        } catch (Exception e) {
            throw new IllegalValueException(MESSAGE_ILLEGAL_DATE_INPUT);
        }
    }
    
    /**
     * Helper method to obtain the recurring period in integer
     * 
     * @param input The recurring period in string 
     * @return The recurring period in integer.
     * @throws NumberFormatException If the Stirng cannot be converted to integer properly.
     */
    public int extractRecurringPeriod(String input) throws NumberFormatException {
        return Integer.parseInt(input);
    }
    
    public static DateParser getInstance() {
        if (instance == null )
            instance = new DateParser();
        return instance;
    }
}
```
###### \java\seedu\taskmaster\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcherNonFloating = NON_FLOATING_TASK_DATA_ARGS_FORMAT.matcher(args.trim());
        if (!matcherNonFloating.matches()) {
            return prepareAddFloating(args);
        }
        return prepareAddNonFloating(args);
    }

    /**
     * Parses arguments in the context of adding a floating task
     * 
     * @param args
     *            full command args string
     * @return the prepared add floating command
     */
    private Command prepareAddFloating(String args) {
        final Matcher matcher = FLOATING_TASK_DATA_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                                      AddFloatingCommand.MESSAGE_USAGE));
        }
        try {
            return new AddFloatingCommand(matcher.group("name"), 
                                          getTagsFromArgs(matcher.group("tagArguments")));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of adding a non floating task
     * 
     * @param args
     *            full command args string
     * @return the prepared add non floating command
     */
    private Command prepareAddNonFloating(String args) {
        final Matcher matcher = NON_FLOATING_TASK_DATA_ARGS_FORMAT.matcher(args.trim());
        matcher.matches();
        if (matcher.group("deadline") != null) {
            return prepareAddNonFloatingByDate(matcher);
        } else {
            return prepareAddNonFloatingFromDateToDate(matcher);
        }
    }

    private RecurringType prepareRecurringTask(String args) {
        final Matcher matcher = RECURRING_TASK_DATA_ARGS_FORMAT.matcher(args.trim());
        RecurringType recurringType = RecurringType.IGNORED;
        if (!matcher.find()) {
            return recurringType;
        } else {
            recurringType = DateParser.getInstance().
                    extractRecurringInfo(matcher.group("recurring"));
        }
        return recurringType;
    }

    private int extractRecurringTaskPeriod(String args) {
        final Matcher matcher = RECURRING_TASK_PERIOD_DATA_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.find()) {
            return Task.NO_RECURRING_PERIOD;
        }
        try {
            final int period = DateParser.getInstance().extractRecurringPeriod(matcher.group("period"));
            return period - RECURRING_PERIOD_OFFSET;
        } catch (NumberFormatException nfe) {
            return Task.NO_RECURRING_PERIOD;
        }
    }

    /**
     * Prepares arguments in the context of adding a non floating task by date
     * only
     * 
     * @param matcher
     *            Contains the information we need
     * @param recurringType
     * @return the prepared add non floating command
     * @throws IllegalValueException
     *             Signals for incorrect command
     */
    private Command prepareAddNonFloatingByDate(Matcher matcher) {
        String endInput = matcher.group("deadline");
        RecurringType recurringType = prepareRecurringTask(endInput);
        if (recurringType == RecurringType.IGNORED) {
            recurringType = RecurringType.NONE;
        }
        final int repeatCount = extractRecurringTaskPeriod(endInput);
        try {
            return new AddNonFloatingCommand(
                   matcher.group("name"), getTagsFromArgs(matcher.group("tagArguments")),
                   new TaskDate(TaskDate.DATE_NOT_PRESENT), 
                   new TaskDate(DateParser.getInstance().getDateFromString(endInput).getTime()),
                   recurringType, repeatCount);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Prepares arguments in the context of adding a non floating task from date
     * to date
     * 
     * @param matcher
     *            Contains the information we need
     * @param recurringType
     * @return the prepared add non floating command
     * @throws IllegalValueException
     *             Signals for incorrect command
     */
    private Command prepareAddNonFloatingFromDateToDate(Matcher matcher) {
        String startInput = matcher.group("startTime");
        String endInput = matcher.group("endTime");
        RecurringType recurringType = prepareRecurringTask(endInput);
        if (recurringType == RecurringType.IGNORED) {
            recurringType = RecurringType.NONE;
        }
        final int repeatCount = extractRecurringTaskPeriod(endInput);        
        try {
            List<Date> datesToAdd = DateParser.getInstance().getFromToDatesFromString(startInput);
            return new AddNonFloatingCommand(
                   matcher.group("name"), getTagsFromArgs(matcher.group("tagArguments")),
                   new TaskDate(datesToAdd.get(START_TIME_INDEX)),
                   new TaskDate(datesToAdd.get(END_TIME_INDEX)), 
                   recurringType, repeatCount);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
```
###### \java\seedu\taskmaster\logic\RecurringTaskManager.java
``` java
/**
 * Handles the behavior of recurring tasks 
 * Dictates when should the recurring tasks be shown.
 * This class is using a singleton pattern. 
 * Use RecurringTaskManager.getInstance() to get the instance of the class
 */
public class RecurringTaskManager {
    private static final int NO_MORE_RECURRING_PERIOD = 0;
    private static RecurringTaskManager instance;
    private static final Logger logger = LogsCenter.getLogger(MainApp.class);
    private UniqueTaskList repeatingTasks;
    private boolean isTestMode;

    public void setTaskList(UniqueTaskList referenceList) {
        assert referenceList != null : "Reference Task list cannot be null";
        logger.fine("Initializing with RecurringTaskManager to manage: " + referenceList.toString());
        repeatingTasks = referenceList;
        isTestMode = false;
    }
    
    /**
     * Test method to check if UniqueTaskList is wired properly to recurringTaskManger
     */
    public UniqueTaskList getTaskList() {
        return repeatingTasks;
    }

    /**
     * Appends any recurring tasks with task occurrences based on their recurring type.
     * 
     * @return True if any task has been updated.
     */
    public boolean appendAnyRecurringTasks() {
        return appendAnyRecurringTasks(LocalDate.now());
    }

    /**
     * Test method to test appendAnyRecurringTasks is working as intended.
     * 
     * @param currentDate The date we want to update towards.
     * @return True if any task has been updated.
     */
    public boolean appendAnyRecurringTasks(LocalDate currentDate) {
        assert repeatingTasks != null : "Repeating Task list reference cannot be null";
        logger.info("=============================[ RecurringTaskManager Updating ]===========================");
        boolean hasUpdated = false;
        for (ReadOnlyTask task : repeatingTasks) {
            if (task.getRecurringType().equals(RecurringType.NONE)) {
                continue;
            }
            attemptAppendRecurringTask(task, currentDate);
            hasUpdated = true;
        }
        return hasUpdated;
    }    
    
    /**
     * Attempts to append a recurring task occurrence to the task if it is possible
     * 
     * @param task Recurring Task to be considered, cannot be null
     * @param currentDate The current date as aLocalDate object.
     */
    public void attemptAppendRecurringTask(ReadOnlyTask task, LocalDate currentDate) {
        TaskOccurrence lastAddedComponent = task.getLastAppendedComponent();
        Calendar startDate = RecurringTaskUtil.getStartCalendar(lastAddedComponent);
        Calendar endDate = RecurringTaskUtil.getEndCalendar(lastAddedComponent);        
        attemptAppendRecurringTask((Task) task, startDate, endDate, currentDate);        
    }

    /**
     * Helper method to append a recurring task occurrence to the task if it is possible
     * Appends a recurring task if there is an elapsed period.
     * 
     * @param task Recurring Task to be considered, cannot be null
     * @param currentDate The current date as aLocalDate object.
     */    
    private void attemptAppendRecurringTask(Task task, Calendar startDate, Calendar endDate, 
            LocalDate localDateCurrently) {
        LocalDate startDateInLocalDate = RecurringTaskUtil.getStartLocalDate(task.getLastAppendedComponent());
        LocalDate endDateInLocalDate = RecurringTaskUtil.getEndLocalDate(task.getLastAppendedComponent());
        final int elapsedPeriod = RecurringTaskUtil.getElapsedPeriodToAppend(localDateCurrently, 
                startDateInLocalDate, endDateInLocalDate, task.getRecurringType());
        for (int i = 0; i < elapsedPeriod; i++) {
            if (handleRecurringPeriod(task)) {
                break;
            }
            appendRecurringTask(task, startDate, endDate);
        }        
    }    
    
    /**
     * Appends the recurring task with a recurring task occurrence.
     * Mutates the repeatingTasks list with the new task occurrence that is appended.
     * 
     * @param task Task which we are appending a new task occurrence to.
     * @param startDate Start date of the last appended task occurrence
     * @param endDate End date of the last appended task occurence
     */
    private void appendRecurringTask(Task task, Calendar startDate, Calendar endDate) {
        RecurringTaskUtil.appendRecurringTask(task, startDate, endDate, repeatingTasks, task.getRecurringType());
    }
    
    /**
     * Corrects the recurring task that are overdued.
     * Only recurring tasks with no recurring period will be corrected.
     * 
     * @param task Recurring task with no stated recurring period.
     */
    public void correctOverdueNonRepeatingTasks(Task task) {
        assert task != null : "task that needs correcting cannot be null!";
        correctAddingOverdueTasks(task, LocalDate.now());
    }

    /**
     * Test method for correcting of overdued recurring tasks with no stated
     * recurring period.
     * 
     * @param task Task to be correct, cannot be null
     * @param currentDate LocalDate that we are correcting towards, cannot be null
     */
    public void correctAddingOverdueTasks(Task task, LocalDate currentDate) {
        assert !CollectionUtil.isAnyNull(task, currentDate);
        if (task.getRecurringType().equals(RecurringType.NONE) 
                || task.getRecurringPeriod() != Task.NO_RECURRING_PERIOD) {
            return;
        }
        LocalDate localDateCurrently = currentDate;
        LocalDate startDateInLocalDate = RecurringTaskUtil.getStartLocalDate(task.getLastAppendedComponent());
        LocalDate endDateInLocalDate = RecurringTaskUtil.getEndLocalDate(task.getLastAppendedComponent());
        attemptCorrectRecurringTask(task, localDateCurrently, startDateInLocalDate, endDateInLocalDate);
    }
    
    /**
     * Attempts to correct recurring tasks without recurring period
     * Corrects the recurring tasks to the next possible date.
     * 
     * @param task Task must be recurring and not have a recurring period.
     * @param localDateCurrently The date currently as a LocalDate form.
     * @param startDateInLocalDate The start date of the task occurrence as a LocalDate object.
     * @param endDateInLocalDate The end date of the task occurrence as a LocalDate object.
     * @param type The current recurring type to correct to.
     */
    private void attemptCorrectRecurringTask(Task task, LocalDate localDateCurrently,
            LocalDate startDateInLocalDate, LocalDate endDateInLocalDate) {
        final int elapsedPeriod = RecurringTaskUtil.getElapsedPeriodToCorrect(
                localDateCurrently, startDateInLocalDate, endDateInLocalDate, task.getRecurringType());
        if (elapsedPeriod > 0) {
            RecurringTaskUtil.correctRecurringTask(task, elapsedPeriod, task.getRecurringType());
        }        
    }

    /**
     * Helper method to handle the recurring period of a recurring task.
     * 
     * @param task Recurring task with or without a recurring period.
     * @return True if there is no longer any recurring period left
     */
    private boolean handleRecurringPeriod(Task task) {
        if (task.getRecurringPeriod() == NO_MORE_RECURRING_PERIOD) {
            return true;   
        }
        task.decrementRecurringPeriod();
        return false;
    }
    
    /**
     * Update recurring tasks after it has been updated.
     * Recurring tasks with recurring period decremented to zero will be ignored.
     * Recurring tasks without recurring period will be updated to the next available slot.
     * 
     * @param target Task Occurrence of the task that we have just archived
     */
    public void updateRecurringTasks(TaskOccurrence target) {
        Task taskDesc = (Task) target.getTaskReference();
        if (taskDesc.getRecurringType().equals(RecurringType.NONE)
                || taskDesc.getRecurringPeriod() == NO_MORE_RECURRING_PERIOD) {
            return;
        }
        Calendar startDate = RecurringTaskUtil.getStartCalendar(target);
        Calendar endDate = RecurringTaskUtil.getEndCalendar(target);
        appendRecurringTask(taskDesc, startDate, endDate);
    }
    
    /**
     * Appends recurring tasks based on its recurring period.
     * A recurring tasks with x recurring period will be appended with x-1 additional task occurrences.
     * 
     * @param task Recurring task with recurring period.
     */
    private void appendRecurringTaskWithPeriod(Task task) {
        if (task.getRecurringType().equals(RecurringType.NONE)
                || task.getRecurringPeriod() == Task.NO_RECURRING_PERIOD) {
            return;
        }
        appendMultipleTaskOccurences(task);
    }

    /**
     * Appends multiple task occurrences for recurring task with recurrinc period.
     * 
     * @param taskDesc Recurring tasks with recurring period.
     */
    private void appendMultipleTaskOccurences(Task taskDesc) {
        TaskOccurrence target = taskDesc.getLastAppendedComponent();
        Calendar startDate = RecurringTaskUtil.getStartCalendar(target);
        Calendar endDate = RecurringTaskUtil.getEndCalendar(target );
        while (taskDesc.getRecurringPeriod() != NO_MORE_RECURRING_PERIOD) {
            appendRecurringTask((Task) taskDesc, startDate, endDate);
            if (taskDesc.getRecurringPeriod()  == Task.NO_RECURRING_PERIOD) {
                return;
            }
            taskDesc.decrementRecurringPeriod();
            target = taskDesc.getLastAppendedComponent();
            startDate = RecurringTaskUtil.getStartCalendar(target);
            endDate = RecurringTaskUtil.getEndCalendar(target);
        } 
    }

    /**
     * Handles the adding of a task in ModelManager
     * 
     * @param task A Task does not need to be recurring
     */
    public void addTask(Task task) {
        if (!isTestMode) {
            correctOverdueNonRepeatingTasks(task);
        }
        appendRecurringTaskWithPeriod(task);        
    }
    
    /**
     * Set the mode of recurring manager. 
     * If isTestMode set to true, recurring manager will not correct recurring tasks for testing purpose.
     * 
     * @param isTestMode If recurring task manager is being tested
     */
    public void setTestMode(boolean isTestMode) {
        this.isTestMode = isTestMode;
    }
    
    public static RecurringTaskManager getInstance() {
        if (instance == null) {
            instance = new RecurringTaskManager();
        }
        return instance;
    }
}
```
###### \java\seedu\taskmaster\logic\util\DateFormatterUtil.java
``` java
/**
 * Provides formatting for Date and LocalDate.
 */
public class DateFormatterUtil {
    private static final int END_DAY_OFFSET = 1;
    /**
     * Returns the end of day in Date format.
     * 
     * @param dateToFormat Date to be formatted, cannot be null.
     * @return Date limited to the end of day e.g. 00.00 of the next day
     */
    public static Date getEndOfDay(Date dateToFormat) {
        assert dateToFormat != null : "Date to be formatted should not be null";
        LocalDate date = dateToFormat.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        date = date.plusDays(END_DAY_OFFSET);
        return Date.from(date.atStartOfDay(ZoneId.systemDefault()).toInstant());
    }
    
    /**
     * Retuns the start of day in Date format.
     * 
     * @param dateToFormat Date to be formatted, cannot be null.
     * @return Date limited to the end of day e.g. 00.00 of the this day
     */
    public static Date getStartOfDay(Date dateToFormat) {
        assert dateToFormat != null : "Date to be formatted should not be null";
        LocalDate date = dateToFormat.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        return Date.from(date.atStartOfDay(ZoneId.systemDefault()).toInstant());
    }

    /**
     * Returns the converted LocalDate object
     * 
     * @param toConvert Date to be formatted, cannot be null.
     * @return Date in LocalDate format.
     */
    public static LocalDate dateToLocalDate(Date toConvert) {
        assert toConvert != null : "Date to be converted should not be null";
        return toConvert.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    }
    
    /**
     * Returns the formatted date in String form
     * 
     * @param toFormat Cannot be null
     */
    public static String getFormattedDate(Date toFormat) {
        SimpleDateFormat formatter = new SimpleDateFormat("EEE, MMM d hh.mma", Locale.ENGLISH);
        return formatter.format(toFormat);
    }
}
```
###### \java\seedu\taskmaster\logic\util\RecurringTaskUtil.java
``` java
/**
 * General utility class for recurring task manager
 */
public class RecurringTaskUtil {
    private static final int INVALID_PERIOD = -1;
    private static final int INDEPTH_CHECK_REQUIRED = 0;
    private static final int APPEND_INCREMENT = 1;
    private static final double NUM_MONTHS_IN_YEAR = 12.0;
    private static final double NUM_WEEKS_IN_MONTH = 4.0;
    private static final double NUM_DAYS_IN_WEEK = 7.0;
    private static final int NUMBER_OF_DAYS_IN_A_WEEK = 7;
    /**
     * Appends recurring tasks into TaskMaster 
     * 
     * @param task The recurring task
     * @param startDate Starting date of the recurring task, can be null
     * @param endDate Ending date of the recurring task, cannot be null
     * @param repeatingTasks Mutable list that is used to keep track of all Task Occurences
     * @param recurringType The recurring type of the task to be appended
     */
    public static void appendRecurringTask(ReadOnlyTask task, Calendar startDate, Calendar endDate, 
            UniqueTaskList repeatingTasks, RecurringType recurringType) {
        Calendar calendar = Calendar.getInstance();
        TaskDate editedStartDate = new TaskDate();
        TaskDate editedEndDate = new TaskDate();
        if (startDate != null) {
            calendar.setTime(startDate.getTime());
            addToCalendar(calendar,recurringType);
            editedStartDate.setDateInLong(calendar.getTime().getTime());
            startDate.setTime(editedStartDate.getDate());
        } else {
            editedStartDate.setDateInLong(TaskDate.DATE_NOT_PRESENT);
        }

        calendar.setTime(endDate.getTime());
        addToCalendar(calendar,recurringType);
        editedEndDate.setDateInLong(calendar.getTime().getTime());
        endDate.setTime(editedEndDate.getDate());   
        
        TaskOccurrence toAppend = new TaskOccurrence((Task) task, editedStartDate, editedEndDate);
        task.appendRecurringDate(toAppend);
        repeatingTasks.appendTaskOccurrence(toAppend);
    }
    
    /**
     * Corrects the start and end date of the recurring task
     * 
     * @param task The recurring task
     * @param elapsedPeriod The difference between the date it is added and the current date
     * @param recurringType Recurring type of the task
     */
    public static void correctRecurringTask(ReadOnlyTask task, int elapsedPeriod, RecurringType recurringType) {
        Calendar calendar = Calendar.getInstance();
        TaskDate correctedStartDate = new TaskDate();
        TaskDate correctedEndDate = new TaskDate();
        TaskDate startDate = task.getLastAppendedComponent().getStartDate();
        TaskDate endDate = task.getLastAppendedComponent().getEndDate();

        if (task.getLastAppendedComponent().isSlot()) {
            calendar.setTime(startDate.getDate());
            correctCalendarByElapsed(calendar, elapsedPeriod, recurringType);
            correctedStartDate.setDateInLong(calendar.getTime().getTime());
        } else {
            correctedStartDate.setDateInLong(TaskDate.DATE_NOT_PRESENT);
        }
        calendar.setTime(endDate.getDate());
        correctCalendarByElapsed(calendar, elapsedPeriod, recurringType);
        correctedEndDate.setDateInLong(calendar.getTime().getTime());

        task.getLastAppendedComponent().setStartDate(correctedStartDate);
        task.getLastAppendedComponent().setEndDate(correctedEndDate);        
    }
    
    /**
     * Helper method to correct the calendar date to the current date using the elapsed period
     * 
     * @param calendar An instance of calendar
     * @param elapsedPeriod The period between days or weeks or months or years
     * @param recurringType Recurring type of the task
     */
    private static void correctCalendarByElapsed(Calendar calendar, int elapsedPeriod, 
            RecurringType recurringType) {
        switch (recurringType) {
            case DAILY:
                calendar.add(Calendar.DAY_OF_MONTH, elapsedPeriod);
                break;
            case WEEKLY:
                calendar.add(Calendar.DAY_OF_MONTH, elapsedPeriod * NUMBER_OF_DAYS_IN_A_WEEK);
                break;
            case MONTHLY:
                calendar.add(Calendar.MONTH, elapsedPeriod);
                break;
            case YEARLY:
                calendar.add(Calendar.YEAR, elapsedPeriod);
                break;
            default:
                assert false : "RecurringType cannot be NONE";
                break;                
        }
    }
    
    /**
     * Returns the number of elapsed time based on the task's recurring type
     * Elapsed time takes into account if the task has a start date or not.
     * If there is no start date, the end date is used to calculate the elapsed period.
     * 
     * @param localDateCurrently Current date as LocalDate object.
     * @param startDateInLocalDate Start date as LocalDate object, can be null.
     * @param endDateInLocalDate End Date as localDate object, cannot be null.
     * @param recurringType Recurring type of the task.
     * @return The number of elapsed time.
     */
    public static int getElapsedPeriodToAppend(LocalDate localDateCurrently, LocalDate startDateInLocalDate,
            LocalDate endDateInLocalDate, RecurringType recurringType) {
        final int elapsed;
        elapsed = getElapsedPeriodByRecurringType(
                          localDateCurrently, startDateInLocalDate, endDateInLocalDate, recurringType);
        return elapsed;
    }
    
    /**
     * Returns the elapsed period between the current date and the start or end date.
     * If start date is not present, the end date is used to get the elapsed period.
     * 
     * @param localDateCurrently The current date as LocalDate object.
     * @param startDateInLocalDate The start date as LocalDate object, can be null.
     * @param endDateInLocalDate The end date as LocalDate object, cannot be null.
     * @param recurringType The recurring type of the task
     * @return The elapsed period based on the recurring type and based on start or end date.
     */
    public static int getElapsedPeriodToCorrect(LocalDate localDateCurrently, LocalDate startDateInLocalDate,
            LocalDate endDateInLocalDate, RecurringType recurringType) {
        final int elapsedPeriod;
        if (startDateInLocalDate != null) {
            elapsedPeriod = getPeriodBetweenDatesToCorrect(
                                    startDateInLocalDate, localDateCurrently, recurringType);
        } else {
            elapsedPeriod = getPeriodBetweenDatesToCorrect(
                                    endDateInLocalDate, localDateCurrently, recurringType);
        }
        return elapsedPeriod;
    }
    
    /**
     * Return the elapsed time between two dates.
     * Elapsed time calculated is based on the recurring type.
     * 
     * @return The elapsed time between two dates and based on the recurring type.
     */
    private static int getPeriodBetweenDatesToCorrect(LocalDate before, LocalDate after, 
            RecurringType recurringType) {
        int elapsedPeriod;
        switch (recurringType) {
            case DAILY:
                elapsedPeriod = (int) ChronoUnit.DAYS.between(before, after);
                break;
            case WEEKLY:
                elapsedPeriod = (int) Math.ceil(ChronoUnit.DAYS.between(before, after) / NUM_DAYS_IN_WEEK);
                break;
            case MONTHLY:
                elapsedPeriod = (int) Math.ceil(ChronoUnit.WEEKS.between(before, after) / NUM_WEEKS_IN_MONTH);
                if (elapsedPeriod == INDEPTH_CHECK_REQUIRED) {
                    elapsedPeriod = getPeriodBetweenDatesToCorrect(before,after,RecurringType.DAILY);
                }
                break;
            case YEARLY:
                elapsedPeriod = (int) Math.ceil(ChronoUnit.MONTHS.between(before, after) / NUM_MONTHS_IN_YEAR);
                if (elapsedPeriod == INDEPTH_CHECK_REQUIRED) {
                    elapsedPeriod = getPeriodBetweenDatesToCorrect(before,after,RecurringType.DAILY);
                }
                break;
            default:
                elapsedPeriod = INVALID_PERIOD;
                assert false : "RecurringType cannot be NONE";
                break;
        }
        return elapsedPeriod;
    }
    
    /**
     * Helper method to add to calendar based on the recurring type.
     * 
     * @param calendar An instance of Calendar.
     * @param recurringType Used to add determine what values are added to the calendar.
     */
    private static void addToCalendar(Calendar calendar, RecurringType recurringType) {
        switch (recurringType) {
            case DAILY:
                calendar.add(Calendar.DAY_OF_MONTH, APPEND_INCREMENT);
                break;
            case WEEKLY:
                calendar.add(Calendar.DAY_OF_MONTH, NUMBER_OF_DAYS_IN_A_WEEK);
                break;
            case MONTHLY:
                calendar.add(Calendar.MONTH, APPEND_INCREMENT);
                break;
            case YEARLY:
                calendar.add(Calendar.YEAR, APPEND_INCREMENT);
                break;
            default:
                assert false : "RecurringType cannot be NONE";
                break;
        }
    }
    
    /**
     * Returns the number of elapsed unit based on the recurring type.
     * Elapsed unit is calculated using the current date and  start date or the end date.
     * If start date is null then end date is used to calculate elapsed.
     * 
     * @param localDateCurrently Current date as a LocalDate object.
     * @param startDateInLocalDate Start date as a LocalDate object, can be null.
     * @param endDateInLocalDate End Date as a LocalDate object, cannot be null.
     * @param recurringType Recurring type of the task.
     * @return The number of elapsed unit.
     */
    private static int getElapsedPeriodByRecurringType(LocalDate localDateCurrently,
            LocalDate startDateInLocalDate, LocalDate endDateInLocalDate, RecurringType recurringType) {
        final int elapsed;
        switch (recurringType) {
            case DAILY:
                if (startDateInLocalDate != null) {
                    elapsed = (int) ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently);
                } else {
                    elapsed = (int) ChronoUnit.DAYS.between(endDateInLocalDate, localDateCurrently);
                }
                break;
            case WEEKLY:
                if (startDateInLocalDate != null) {
                    elapsed = (int) Math.ceil(ChronoUnit.DAYS.between(startDateInLocalDate, localDateCurrently) 
                                               / NUM_DAYS_IN_WEEK);
                } else {
                    elapsed = (int) Math.ceil(ChronoUnit.DAYS.between(endDateInLocalDate, localDateCurrently) 
                                               / NUM_DAYS_IN_WEEK);
                }
                break;
            case MONTHLY:
                if (startDateInLocalDate != null) {
                    elapsed = (int) Math.ceil(ChronoUnit.WEEKS.between(startDateInLocalDate, localDateCurrently) 
                                              / NUM_WEEKS_IN_MONTH);
                } else {
                    elapsed = (int) Math.ceil(ChronoUnit.WEEKS.between(endDateInLocalDate, localDateCurrently) 
                                              / NUM_WEEKS_IN_MONTH);
                }                
                break;
            case YEARLY:
                if (startDateInLocalDate != null) {
                    elapsed = (int) Math.ceil(ChronoUnit.MONTHS.between(startDateInLocalDate, localDateCurrently) 
                                              / NUM_MONTHS_IN_YEAR);
                } else {
                    elapsed = (int) Math.ceil(ChronoUnit.MONTHS.between(endDateInLocalDate, localDateCurrently) 
                                              / NUM_MONTHS_IN_YEAR);
                }                
                break;
            default:
                elapsed = INVALID_PERIOD;
                assert false : "Recurring Type must not be NONE";
        }
        return elapsed;
    }

    /**
     * Gets the start date as a Calendar object.
     * 
     * @param target Cannot be null
     * @return null if there is no start date in target
     */
    public static Calendar getStartCalendar(TaskOccurrence target) {
        if (!target.getStartDate().isPresent()) {
            return null;
        }
        Calendar startDate = new GregorianCalendar();
        startDate.setTime(target.getStartDate().getDate());
        return startDate;
    }

    /**
     * Gets the end date as a Calendar object.
     * 
     * @param target Cannot be null
     * @return end date of target as Calendar object.
     */    
    public static Calendar getEndCalendar(TaskOccurrence target) {
        Calendar endDate = new GregorianCalendar();
        endDate.setTime(target.getEndDate().getDate());
        return endDate;
    }

    /**
     * Gets the start date as a LocalDate object.
     * 
     * @param target Cannot be null
     * @return null if there is no start date in target
     */
    public static LocalDate getStartLocalDate(TaskOccurrence target) {
        if (!target.isSlot()) {
            return null;
        }
        return DateFormatterUtil.dateToLocalDate(target.getStartDate().getDate());
    }

    /**
     * Gets the end date as a LocalDate object.
     * 
     * @param target Cannot be null
     * @return end date of target as LocalDate object.
     */        
    public static LocalDate getEndLocalDate(TaskOccurrence target) {
        return DateFormatterUtil.dateToLocalDate(target.getEndDate().getDate());
    }
}
```
###### \java\seedu\taskmaster\model\ModelManager.java
``` java
    /**
     * Initializes a ModelManager with the given TaskList TaskList and its
     * variables should not be null
     */
    public ModelManager(TaskMaster src, UserPrefs userPrefs) {
        super();
        assert src != null;
        assert userPrefs != null;
        logger.fine("Initializing with address book: " + src + " and user prefs " + userPrefs);

        taskMaster = new TaskMaster(src);
        tasks = taskMaster.getTasks();
        filteredTaskComponents = new FilteredList<>(taskMaster.getTaskOccurrenceList());
        initRecurringTaskManager();
        initPreviousDateAndExpression();
    }
```
###### \java\seedu\taskmaster\model\ModelManager.java
``` java
    public ModelManager(ReadOnlyTaskMaster initialData, UserPrefs userPrefs) {
        taskMaster = new TaskMaster(initialData);
        tasks = taskMaster.getTasks();

        filteredTaskComponents = new FilteredList<>(taskMaster.getTaskOccurrenceList());
        initRecurringTaskManager();
        initPreviousDateAndExpression();
    }
    
    /**
     * Initialises RecurringTaskManager with the uniqueTaskList from taskMaster
     */
    private void initRecurringTaskManager() {
        RecurringTaskManager.getInstance().setTaskList(taskMaster.getUniqueTaskList());
        if (RecurringTaskManager.getInstance().appendAnyRecurringTasks()) {
            indicateTaskListChanged();
        }
    }    
```
###### \java\seedu\taskmaster\model\ModelManager.java
``` java
    /**
     * Adds any task into the taskMaster
     * If it is a recurring task, it will be handled by RecurringTaskManager
     */
    @Override
    public synchronized void addTask(Task task) 
            throws UniqueTaskList.DuplicateTaskException, TimeslotOverlapException {
        taskMaster.addTask(task);
        RecurringTaskManager.getInstance().addTask(task);
        updateFilteredListToShowAll();
        indicateTaskListChanged();
    }

```
###### \java\seedu\taskmaster\model\ModelManager.java
``` java
    private class ArchiveQualifier implements Qualifier {
        private boolean isArchived;

        ArchiveQualifier(boolean isItArchive) {
            this.isArchived = isItArchive;
        }

        @Override
        public boolean run(TaskOccurrence task) {
            return task.isArchived() == isArchived;
        }

    }
```
###### \java\seedu\taskmaster\model\task\RecurringType.java
``` java
public enum RecurringType {
    NONE,
    DAILY,
    WEEKLY,
    MONTHLY,
    YEARLY,
    IGNORED //Merely for parsing
}
```
###### \java\seedu\taskmaster\model\task\Task.java
``` java
    @Override
    public List<TaskOccurrence> getTaskDateComponent() {
        return recurringDates;
    }

    @Override
    public TaskType getTaskType() {
        return taskType;
    }

    @Override
    public RecurringType getRecurringType() {
        return recurringType;
    }

    public void setTaskType(TaskType type) {
        this.taskType = type;
    }

    /**
     * Sets the recurring type for the Task.
     * Floating Task cannot have a recurring type.
     * 
     * @param type The recurring type, cannot be null
     */
    public void setRecurringType(RecurringType type) {
        if (taskType == TaskType.FLOATING) {
            assert (type.equals(RecurringType.NONE)) : "Floating Task cannot be a recurring task";
        }
        this.recurringType = type;
    }

```
###### \java\seedu\taskmaster\model\task\Task.java
``` java
    /**
     * Mark a task completed if all of its TaskOccurrences are archived.
     */
    @Override
    public void completeTaskWhenAllOccurrencesArchived() {
        for (TaskOccurrence c : recurringDates) {
            if (c.isArchived() == false 
                    || c.getTaskReference().getRecurringType() != RecurringType.NONE) {
                return;
            }
        }
        taskType = TaskType.COMPLETED;
    }
```
###### \java\seedu\taskmaster\model\task\Task.java
``` java

    @Override
    public TaskOccurrence getLastAppendedComponent() {
        return recurringDates.get(recurringDates.size() - INDEX_OFFSET);
    }

    /**
     * Appends a recurring task with a task occurrence
     * Non Recurring Task cannot be appended with task occurrence.
     */
    @Override
    public void appendRecurringDate(TaskOccurrence componentToBeAdded) {
        assert !recurringType.equals(RecurringType.NONE) : "You cannot append new dates to non recurring tasks";
        recurringDates.add(componentToBeAdded);
        recurringDates.get(recurringDates.size() - INDEX_OFFSET).setTaskReferrence(this);
    }
    
    /**
     * Returns the recurring period of the task
     * Non Recurring Task will not have a valid recurring period.
     */
    @Override
    public int getRecurringPeriod() {
        if (recurringType.equals(RecurringType.NONE)) {
            return NO_RECURRING_PERIOD;
        }
        return recurringPeriod;
    }
    
    public int decrementRecurringPeriod() {
        recurringPeriod -= PERIOD_DECREMENT;
        return recurringPeriod;
    }
```
###### \java\seedu\taskmaster\model\task\TaskDate.java
``` java
/**
 * Helper class for storing date for the Task
 */
public class TaskDate {
    private static final String NO_DATE_PRESENT = "";
    public static final int DATE_NOT_PRESENT = -1;
    private long date;
    
    /**
     * Date is not present by default if nothing is specified
     * Convenience and defensive
     */
    public TaskDate() {
        this.date = DATE_NOT_PRESENT;
    }
    
    public TaskDate(Date date) {
        this.date = date.getTime();
    }
    
    public TaskDate(long date) {
        this.date = date;
    }
        
    public TaskDate(TaskDate copy) {
        this.date = copy.date;
    }
    
```
###### \java\seedu\taskmaster\model\task\TaskDate.java
``` java
    public void setDateInLong(long date) {
        this.date = date;
    }
    /**
     * Formats the date in (EEE, MMM d hh.mma) format which will give MON, Oct 20 10.00PM
     * If there is no date present return empty string
     * @return Empty string if there is no date present
     *          Formatted date if there is date
     */
    public String getFormattedDate() {
        if (date == DATE_NOT_PRESENT) {
            return NO_DATE_PRESENT;
        }
        return DateFormatterUtil.getFormattedDate(new Date(date));
    }
    //@author
    
    //For sake of testing
    public String getInputDate() {
        if (date == DATE_NOT_PRESENT) {
            return NO_DATE_PRESENT;
        }
        SimpleDateFormat formatter = new SimpleDateFormat("dd MMM hha", Locale.ENGLISH);
        return formatter.format(new Date(date));
    }
    
```
###### \java\seedu\taskmaster\model\task\TaskDate.java
``` java
    public long getDateInLong() {
        return date;
    } 
    
    /**
     * Parses the date in Long and provides it in the Date class format
     */
    public Date getDate() {
    	return new Date(date);
    }
    
    @Override
    public boolean equals(Object other){
		return other == this 
		       || (other instanceof TaskDate // instance of handles nulls
		           && this.getDate().equals(((TaskDate) other).getDate()));
    }

    public boolean isPresent() {
        return date != DATE_NOT_PRESENT;
    }
    
    @Override
    public String toString() {
        return getFormattedDate();
    }
}
```
###### \java\seedu\taskmaster\model\task\TaskOccurrence.java
``` java
/** 
* This class served as the occurrence portion in an abstraction occurrence pattern.
* The abstraction is the Task and the occurrence is the TaskDateComponent.
*/
public class TaskOccurrence {
    private Task taskReference;
    private TaskDate startDate, endDate;
    private boolean isArchived;
    
    public TaskOccurrence(Task taskReference, TaskDate startDate, TaskDate endDate) {
        assert !CollectionUtil.isAnyNull(startDate, endDate);
        this.startDate = new TaskDate(startDate);
        this.endDate = new TaskDate(endDate);
        this.taskReference = taskReference;
    }
    
    public TaskOccurrence(TaskOccurrence taskDateComponent) {
        assert taskDateComponent != null : "Cannot pass in null values";
        this.taskReference = taskDateComponent.taskReference;
        this.startDate = taskDateComponent.startDate;
        this.endDate = taskDateComponent.endDate;
        this.isArchived = taskDateComponent.isArchived;
    }

    public void setStartDate(TaskDate startDate) {
        this.startDate = startDate;
    }
    
    public void setEndDate(TaskDate endDate) {
        this.endDate = endDate;
    }
    
    public void setTaskReferrence(Task task) {
    	this.taskReference = task;
    }
    
    public TaskDate getStartDate() {
        return startDate;
    }
    
    public TaskDate getEndDate() {
        return endDate;
    }
    
```
###### \java\seedu\taskmaster\model\task\TaskOccurrence.java
``` java
    public boolean isArchived() {
        return isArchived;
    }
    
    private boolean isSameStateAs(TaskOccurrence other) {
        return other == this // short circuit if same object
               || (other != null // this is first to avoid NPE below
                   && other.getTaskReference().getName().equals(this.getTaskReference().getName()) // state checks here onwards
                   && other.getTaskReference().getTaskType().equals(this.getTaskReference().getTaskType())
                   && other.getStartDate().equals(this.getStartDate())
                   && other.getEndDate().equals(this.getEndDate()));
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
               || (other instanceof TaskOccurrence // instanceof handles nulls
                   && this.isSameStateAs((TaskOccurrence) other));        
    }
}
```
###### \java\seedu\taskmaster\model\task\TaskType.java
``` java
public enum TaskType {
    FLOATING,
    NON_FLOATING, 
    COMPLETED
}
```
###### \java\seedu\taskmaster\model\task\UniqueTaskList.java
``` java
    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException 
     *                 If the task is a non recurring task is a duplicate of an existing task in the list.
     * @throws TimeslotOverlapException 
     *                 If the task is cutting into an overlapped slot.
     */
    public void add(Task toAdd) throws DuplicateTaskException, TimeslotOverlapException {
        assert toAdd != null;
        if (contains(toAdd)) {
            if (!toAdd.getRecurringType().equals(RecurringType.NONE)) {
                appendDuplicateRecurringDatesToTask(toAdd);
                return;
            }
            throw new DuplicateTaskException();
        }
        if (overlaps(toAdd)) {
            throw new TimeslotOverlapException();
        }
        internalList.add(toAdd);
        internalOccurrenceList.addAll(toAdd.getTaskDateComponent());
    }

    /**
     * Append duplicate recurring task together into a single unique task
     * 
     * @param toAdd Task to be appended into a single unique task.
     */
    private void appendDuplicateRecurringDatesToTask(Task toAdd) {
        int idx = internalList.indexOf(toAdd);
        Task toBeAppendedOn = internalList.get(idx);
        internalOccurrenceList.add(toAdd.getLastAppendedComponent());
        toBeAppendedOn.appendRecurringDate(toAdd.getLastAppendedComponent());
    }
```
###### \java\seedu\taskmaster\storage\XmlAdaptedTaskOccurrence.java
``` java
    @XmlElement
    private long startDate;
    @XmlElement
    private long endDate;
    @XmlElement
    private String recurringType;
    @XmlElement
    private int recurringPeriod;
    @XmlElement
    private boolean isArchived;
    
    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTaskOccurrence() {}

    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTaskOccurrence(TaskOccurrence source) {
        name = source.getTaskReference().getName().fullName;
        tagged = new ArrayList<>();
        for (Tag tag : source.getTaskReference().getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
        handleDatesByTaskType(source);
        handleDatesByRecurringType(source);
        recurringType = source.getTaskReference().getRecurringType().name();
        recurringPeriod = source.getTaskReference().getRecurringPeriod();
        isArchived = source.isArchived();
    }

    /**
     * Saves dates only if it has been archived.
     */
    private void handleDatesByRecurringType(TaskOccurrence source) {
        if (source.getTaskReference().getRecurringType() != RecurringType.NONE && source.isArchived()) {
            TaskDate startCopy = new TaskDate(source.getStartDate());
            TaskDate endCopy = new TaskDate(source.getEndDate());
            startDate = startCopy.getDateInLong();
            endDate = endCopy.getDateInLong();
        }
    }

    /**
     * Saves dates based on the task type of the task occurrence.
     */
    private void handleDatesByTaskType(TaskOccurrence source) {
        if (source.getTaskReference().getTaskType() == TaskType.NON_FLOATING 
                || source.getTaskReference().getTaskType() == TaskType.COMPLETED) {
            startDate = source.getStartDate().getDateInLong();
            endDate = source.getEndDate().getDateInLong();
        } else {
            startDate = TaskDate.DATE_NOT_PRESENT;
            endDate = TaskDate.DATE_NOT_PRESENT;
        }
    }
    
    /**
     * Converts this jaxb-friendly adapted task occurrence object into the model's TaskOccurrence object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        if (endDate != TaskDate.DATE_NOT_PRESENT) {
            return toModelTypeNonFloating(name, tags);
        }
        return toModelTypeFloating(name, tags);
    }

    /**
     * Converts this jaxb-friendly adapted task occurrence object into the model's TaskOccurrence object for floating tasks.
     */
    private Task toModelTypeFloating(final Name name, final UniqueTagList tags) {
    	Task task = new Task(name, tags);
    	processArchivedTasks(task);
        return task;
    }

    /**
     * Converts this jaxb-friendly adapted task occurrence object into the model's TaskOccurrence object for non floating tasks.
     */
    private Task toModelTypeNonFloating(final Name name, final UniqueTagList tags) {
        final TaskDate taskStartDate = new TaskDate(startDate);
        final TaskDate taskEndDate = new TaskDate(endDate);
        RecurringType toBeAdded = RecurringType.NONE;
        if (recurringType != null ) {
            toBeAdded = RecurringType.valueOf(recurringType);
        }
        Task task = new Task(name, tags, taskStartDate, taskEndDate, toBeAdded, recurringPeriod);
        processArchivedTasks(task);
        return task;
    }

    /**
     * Processes archived task before it is loaded into the UI.
     * @param task The task that we are currently loading
     */
    private void processArchivedTasks(Task task) {
        if (isArchived) {
        	task.setTaskType(TaskType.COMPLETED);
        	for (TaskOccurrence t: task.getTaskDateComponent()) {
        		t.archive();
        	}
        }
    }
```
###### \resources\view\TaskListCard.fxml
``` fxml
								<Label fx:id="recurringType" minHeight="-Infinity" minWidth="-Infinity" prefHeight="25.0" prefWidth="75.0" text="\$recurringType" translateX="-180.0" translateY="55.0" />
```
