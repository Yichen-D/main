# A0147967J
###### \java\guitests\AddCommandTest.java
``` java
        // add one non-floating task
        taskToAdd = td.project;
        assertAddNonFloatingSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        // Unrecognizable recurring type recognized as normaltask
        // duplicate non-floating not allowed
        commandBox.runCommand(td.project.getAddNonFloatingCommand() + "not a type");
        assertResultMessage(AddNonFloatingCommand.MESSAGE_DUPLICATE_TASK);
        assertTrue(taskListPanel.isListMatching(TestUtil.convertTasksToDateComponents(currentList)));

        // add deadline task
        taskToAdd = td.paper;
        assertAddNonFloatingSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        // add task with overlapping slot allowed
        taskToAdd = td.movie;
        assertAddNonFloatingSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        // add task with illegal time slot
        commandBox.runCommand("add illegal timeslot from 2 oct 2pm to 2 oct 1pm");
        assertResultMessage(AddNonFloatingCommand.MESSAGE_ILLEGAL_TIME_SLOT);
        assertTrue(taskListPanel.isListMatching(TestUtil.convertTasksToDateComponents(currentList)));

        // add to empty list
        commandBox.runCommand("clear");
        assertAddSuccess(td.trash);
        currentList = new TestTask[] { td.trash };

        // invalid command
        commandBox.runCommand("adds Johnny");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        // ======Cases for handling recurring tasks==================================================

        // Out dated Recurring task got updated
        taskToAdd = td.daily;
        assertAddCommandSuccess("add Daily Task from yesterday 7am to yesterday 8am daily", taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        // Up to date remain stayed
        taskToAdd = td.weekly;
        assertAddCommandSuccess(taskToAdd.getAddRecurringCommand(), taskToAdd, currentList);
        
    }

    private void assertAddSuccess(TestTask taskToAdd, TestTask... currentList) {
        assertAddCommandSuccess(taskToAdd.getAddFloatingCommand(), taskToAdd, currentList);
    }

    private void assertAddNonFloatingSuccess(TestTask taskToAdd, TestTask... currentList) {
        assertAddCommandSuccess(taskToAdd.getAddNonFloatingCommand(), taskToAdd, currentList);
    }

    private void assertAddCommandSuccess(String command, TestTask taskToAdd, TestTask... currentList) {

        commandBox.runCommand(command);
        // confirm the new card contains the right data
        TaskCardHandle addedCard = taskListPanel.navigateToTask(taskToAdd.getName().fullName);
        assertMatching(taskToAdd.getTaskDateComponent().get(0), addedCard);

        // confirm the list now contains all previous floatingTasks plus the new
        // floatingTask
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, taskToAdd);

        TaskOccurrence[] taskComponents = TestUtil.convertTasksToDateComponents(expectedList);
        assertTrue(taskListPanel.isListMatching(taskComponents));
    }
}
```
###### \java\guitests\BrowserPanelTest.java
``` java
/**
 * Tests if browser panel can display correct tasks.
 */
public class BrowserPanelTest extends TaskMasterGuiTest {

    private final long DAY = 24 * 60 * 60 * 1000;

    @Test
    public void browserPanelTestWithoutRecurringPeriod() {

        // Initial case: Out dated tasks/floating/deadlines not displayed, in
        // the list 10 tasks
        assertEquals(0, browser.getMyAgenda().appointments().size());

        // Add Non recurring tasks display once
        TestTask toBeAdded = td.none;
        ArrayList<TaskOccurrence> expectedList = new ArrayList<TaskOccurrence>();
        expectedList.add(toBeAdded.getLastAppendedComponent());
        commandBox.runCommand(toBeAdded.getAddNonFloatingCommand());
        assertIsAgendaMatching(expectedList);

        // Add weekly, monthly or yearly display once
        toBeAdded = td.weekly;
        expectedList.add(toBeAdded.getLastAppendedComponent());
        commandBox.runCommand(toBeAdded.getAddRecurringCommand());
        assertIsAgendaMatching(expectedList);

        toBeAdded = td.monthly;
        expectedList.add(toBeAdded.getLastAppendedComponent());
        commandBox.runCommand(toBeAdded.getAddRecurringCommand());
        assertIsAgendaMatching(expectedList);

        toBeAdded = td.yearly;
        expectedList.add(toBeAdded.getLastAppendedComponent());
        commandBox.runCommand(toBeAdded.getAddRecurringCommand());
        assertIsAgendaMatching(expectedList);

        // Add daily tasks, depends on day of week, add copies
        toBeAdded = td.daily;
        expectedList.add(toBeAdded.getLastAppendedComponent());
        expectedList.addAll(getCopies(toBeAdded.getLastAppendedComponent()));
        commandBox.runCommand(toBeAdded.getAddRecurringCommand());
        assertIsAgendaMatching(expectedList);

        // Archive current task, style change reflected
        toBeAdded.getLastAppendedComponent().archive();
        TaskOccurrence toBeArchived = toBeAdded.getLastAppendedComponent();
        expectedList.set(4, toBeArchived);
        commandBox.runCommand("done 15");
        assertIsAgendaMatching(expectedList);

        // With block command, style change reflected
        toBeAdded = td.block;
        expectedList.add(toBeAdded.getLastAppendedComponent());
        commandBox.runCommand(toBeAdded.getBlockCommand());
        assertIsAgendaMatching(expectedList);
        
        //Random day, nothing displayed
        expectedList.clear();
        commandBox.runCommand("view last year today");
        assertIsAgendaMatching(expectedList);
        
    }
    
    @Test 
    public void browserPanelWithRecurringPeriod(){
        
        //Take daily tasks as example
        TestTask toBeAdded = td.daily;
        ArrayList<TaskOccurrence> expectedList = new ArrayList<TaskOccurrence>();
        expectedList.add(toBeAdded.getLastAppendedComponent());
        int recurringCount = 7 - MyAgendaUtil.getConvertedTime(toBeAdded.getLastAppendedComponent().getStartDate()).getDayOfWeek().getValue() % 7;
        expectedList.addAll(getCopies(toBeAdded.getLastAppendedComponent()));
        commandBox.runCommand(toBeAdded.getAddRecurringCommand() + " repeat " + recurringCount);
        assertIsAgendaMatching(expectedList);
        
        //View next week lists nothing
        expectedList.clear();
        commandBox.runCommand("view next week");
        assertIsAgendaMatching(expectedList);
    }

    private ArrayList<TaskOccurrence> getCopies(TaskOccurrence t) {
        ArrayList<TaskOccurrence> list = new ArrayList<TaskOccurrence>();
        int dayOfWeek = MyAgendaUtil.getConvertedTime(t.getStartDate()).getDayOfWeek().getValue() % 7;
        for (int i = 1; i <= 6 - dayOfWeek; i++) {
            TaskOccurrence copy = new TaskOccurrence(t);
            copy.setStartDate(new TaskDate(t.getStartDate().getDateInLong() + DAY * i));
            copy.setEndDate(new TaskDate(t.getEndDate().getDateInLong() + DAY * i));
            list.add(copy);
        }
        return list;
    }
}
```
###### \java\guitests\CompleteCommandTest.java
``` java
/**
 * Tests if the correct task can be marked as done.
 */
public class CompleteCommandTest extends TaskMasterGuiTest {

    @Test
    public void complete() {
        commandBox.runCommand("list"); //switch to all tasks first

        // done the first in the list
        TestTask[] currentList = td.getTypicalTasks();
        TestTask[] completed = new TestTask[3];
        int targetIndex = 1;
        completed[0] = currentList[targetIndex - 1];
        assertCompleteSuccess(targetIndex, currentList);
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);

        // done the last in the list
        targetIndex = currentList.length;
        completed[2] = currentList[targetIndex - 1];
        assertCompleteSuccess(targetIndex, currentList);
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        
        // done from the middle of the list
        targetIndex = 3;
        completed[1] = currentList[targetIndex - 1];
        assertCompleteSuccess(targetIndex, currentList);
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        
        // invalid index
        commandBox.runCommand("done " + currentList.length + 1);
        assertResultMessage("The task index provided is invalid");

        // Check changes are reflected in Completed panel
        // Noted that completed tasks are not listed in the archive order but
        // adding order.
        commandBox.runCommand("find -C");
        assertTrue(taskListPanel.isListMatching(TestUtil.convertTasksToDateComponents(completed)));

    }

    /**
     * Runs the delete command to delete the floatingTask at specified index and
     * confirms the result is correct.
     * 
     * @param targetIndexOneIndexed
     *            e.g. to delete the first floatingTask in the list, 1 should be
     *            given as the target index.
     * @param currentList
     *            A copy of the current list of floatingTasks (before deletion).
     */
    private void assertCompleteSuccess(int targetIndexOneIndexed, final TestTask[] currentList) {
        TestTask taskToComplete = currentList[targetIndexOneIndexed - 1]; // -1
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("done " + targetIndexOneIndexed);

        // confirm the list now contains all previous floatingTasks except the
        // deleted floatingTask
        assertTrue(taskListPanel.isListMatching(TestUtil.convertTasksToDateComponents(expectedRemainder)));

        // confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_COMPLETE_TASK_SUCCESS, taskToComplete.getLastAppendedComponent()));
    }

}
```
###### \java\guitests\EditCommandTest.java
``` java
public class EditCommandTest extends TaskMasterGuiTest {

    @Test
    public void edit() throws IllegalValueException {
        commandBox.runCommand("list"); //switch to all tasks first

        // Fix Index first to see edit effect
        // edit deadline
        int index = 4;
        TestTask[] currentList = td.getTypicalTasks();
        TestTask toBeEdited = currentList[index - 1];
        toBeEdited.setEndDate("2 oct 10am");
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 by 2 oct 10am", currentList);

        // edit it to time slot
        toBeEdited = currentList[index - 1];
        toBeEdited.setStartDate("2 oct 9am");
        toBeEdited.setEndDate("2 oct 11am");
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 from 2 oct 9am to 2 oct 11am", currentList);

        // add a tag
        toBeEdited = currentList[index - 1];
        toBeEdited.setTag(new UniqueTagList(new Tag("testTag")));
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 t/testTag", currentList);

        // add tags
        toBeEdited = currentList[index - 1];
        toBeEdited.setTag(new UniqueTagList(new Tag("testTag1"), new Tag("testTag2")));
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 t/testTag1 t/testTag2", currentList);

        // change name
        toBeEdited = currentList[index - 1];
        toBeEdited.setName(new Name("Test name"));
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 Test name", currentList);

        // invalid index
        commandBox.runCommand("edit " + currentList.length + 1 + " invalid index");
        assertResultMessage("The task index provided is invalid");

        // invalid command
        commandBox.runCommand("edits read weblecture");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        // Edit a normal task to a recurring task
        toBeEdited = currentList[index - 1];
        toBeEdited.setRecurringType(RecurringType.MONTHLY);
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 monthly", currentList);

        // Edit it back also enabled
        toBeEdited = currentList[index - 1];
        toBeEdited.setRecurringType(RecurringType.NONE);
        currentList[index - 1] = toBeEdited;
        assertEditSuccess(toBeEdited, "edit 4 none", currentList);

    }

    private void assertEditSuccess(TestTask editedCopy, String command, TestTask... modifiedList) {

        commandBox.runCommand(command);

        // confirm the new card contains the right data
        TaskCardHandle editedCard = taskListPanel.navigateToTask(editedCopy.getName().fullName);
        assertMatching(editedCopy.getTaskDateComponent().get(0), editedCard);

        // confirm the list now contains all the unmodified tasks and the edited
        // task
        TaskOccurrence[] taskComponents = TestUtil.convertTasksToDateComponents(modifiedList);

        assertTrue(taskListPanel.isListMatching(taskComponents));
        assertResultMessage(String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS, editedCopy.getLastAppendedComponent()));
    }

}
```
###### \java\guitests\FindCommandTest.java
``` java
    @Test
    public void find_byDeadline() {
        try {
            // By time-after and sharp
            assertFindResult("find by 18 oct 5pm", td.labDeadline.getTaskDateComponent().get(0));
            // By time-before
            assertFindResult("find by 18 oct 4.59pm");
        } catch (Exception e) {
        }
    }

    
    @Test
    public void find_byTimeSlot() {
        // Cover multiple
        assertFindResult("find from 17 oct 10am to 17 oct 10pm", td.tutorialSlot.getTaskDateComponent().get(0),
                td.concert.getTaskDateComponent().get(0));
        // Cover one
        assertFindResult("find from 17 oct 10am to 17 oct 3pm", td.tutorialSlot.getTaskDateComponent().get(0));
        // Cover none
        assertFindResult("find from 17 oct 5pm to 17 oct 6pm");
    }

    @Test
    public void find_byTag() {
        // Existing one tag one result successful
        assertFindResult("find t/textBook", td.book.getTaskDateComponent().get(0));
        // Existing multiple tags multiple results successful
        assertFindResult("find t/CS2105 t/textBook", td.book.getTaskDateComponent().get(0),
                td.homework.getTaskDateComponent().get(0));
        // Invalid/Non-existing tag lists nothing
        assertFindResult("find t/nothing");
        assertFindResult("find t/--[][]");
    }

    @Test
    public void find_byType() {
        // Floating tasks
        assertFindResult("find -F", td.trash.getTaskDateComponent().get(0), td.book.getTaskDateComponent().get(0),
                td.homework.getTaskDateComponent().get(0), td.lecture.getTaskDateComponent().get(0),
                td.meeting.getTaskDateComponent().get(0), td.george.getTaskDateComponent().get(0));
        // Completed tasks
        commandBox.runCommand("done 1");
        assertFindResult("find -C", td.trash.getTaskDateComponent().get(0));
    }

```
###### \java\guitests\guihandles\BrowserPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the task list.
 */
public class BrowserPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;

    private static final String AGENDA_ID = "#agenda";

    public BrowserPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public MyAgenda getMyAgenda() {
        return (MyAgenda) getNode(AGENDA_ID);
    }

    public boolean isContained(AppointmentImplLocal target) {
        for (Appointment a : getMyAgenda().appointments())
            if (MyAgendaUtil.isSameAppointment(a, target))
                return true;
        return false;
    }

}
```
###### \java\guitests\guihandles\NavbarPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the task list.
 */
public class NavbarPanelHandle extends GuiHandle {

    private final String NAVBAR_TASKS = " Tasks";
    private final String NAVBAR_DEADLINES = " Deadlines";
    private final String NAVBAR_INCOMING_DEADLINES = " Incoming Deadlines";
    private final String NAVBAR_FLOATING_TASKS = " Floating Tasks";
    private final String NAVBAR_COMPLETED = " Completed";
    private final String NAVBAR_TODAY = " Today";

    private final ObservableList<String> navbarElement = FXCollections.observableArrayList(NAVBAR_TODAY, NAVBAR_TASKS,
            NAVBAR_DEADLINES, NAVBAR_FLOATING_TASKS, NAVBAR_INCOMING_DEADLINES, NAVBAR_COMPLETED);

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPaneNav";

    private static final String TASK_LIST_VIEW_ID = "#navbarView";

    public NavbarPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    @SuppressWarnings("unchecked")
    public ListView<String> getListView() {
        return (ListView<String>) getNode(TASK_LIST_VIEW_ID);
    }

    /**
     * Navigates the list view to display and select the task.
     */
    public void navigateTo(String nav) {
        int index = navbarElement.indexOf(nav);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(550);

    }
}
```
###### \java\guitests\NavbarPanelTest.java
``` java
public class NavbarPanelTest extends TaskMasterGuiTest {

    private final String NAVBAR_TASKS = " Tasks";
    private final String NAVBAR_DEADLINES = " Deadlines";
    private final String NAVBAR_INCOMING_DEADLINES = " Incoming Deadlines";
    private final String NAVBAR_FLOATING_TASKS = " Floating Tasks";
    private final String NAVBAR_COMPLETED = " Completed";
    private final String NAVBAR_TODAY = " Today";

    @Test
    public void navigateToFloatingTasks() {
        TaskOccurrence[] expected;
        // Navigate to all floating tasks
        expected = Arrays.copyOfRange(td.getTypicalTaskComponents(), 0, 6);
        assertResult(NAVBAR_FLOATING_TASKS, expected);
    }

    @Test
    public void navigateToDeadlines() {
        // Navigate to deadlines
        assertResult(NAVBAR_DEADLINES, td.labDeadline.getLastAppendedComponent(),
                td.essayDeadline.getLastAppendedComponent());
    }

    @Test
    public void navigateToIncomingDeadlines() {
        // Navigate to incoming deadlines
        commandBox.runCommand(td.incoming.getAddNonFloatingCommand());
        assertResult(NAVBAR_INCOMING_DEADLINES, td.labDeadline.getLastAppendedComponent(),
                td.essayDeadline.getLastAppendedComponent(), td.incoming.getLastAppendedComponent());
    }

    @Test
    public void navigateToAllTasks() {
        // Navigate to all tasks
        TaskOccurrence[] expected = td.getTypicalTaskComponents();
        assertResult(NAVBAR_TASKS, expected);
    }

    @Test
    public void navigateToCompletedOnes() {
        // Navigate to completed ones
        commandBox.runCommand("list"); //switch to all tasks first
        commandBox.runCommand("done 1");
        assertResult(NAVBAR_COMPLETED, td.trash.getLastAppendedComponent());
    }
    
    @Test
    public void navigateToToday() {
        // Navigate to today's tasks, here should be none.
        assertResult(NAVBAR_TODAY);
    }

    private void assertResult(String navigation, TaskOccurrence... expectedHits) {
        navbar.navigateTo(navigation);
        assertListSize(expectedHits.length);
        if (navigation.equals(NAVBAR_TASKS))
            assertResultMessage("Listed all tasks");
        else
            assertResultMessage(expectedHits.length + " tasks listed!");
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }

}
```
###### \java\guitests\TaskMasterGuiTest.java
``` java
    /**
     * Asserts the expected task components are reflected in the agenda.
     * @param expected
     */
    protected void assertIsAgendaMatching(ArrayList<TaskOccurrence> expectedShown){
		//Get the updated agenda
		MyAgenda toBeChecked = browser.getMyAgenda();
		//Checks the number of items in the agenda
		assertEquals(expectedShown.size(), toBeChecked.appointments().size());
		//Checks one-to-one match
		for(TaskOccurrence t: expectedShown){
			assertTrue(browser.isContained(MyAgendaUtil.getAppointment(t)));
		}
	}

}
```
###### \java\guitests\ViewCommandTest.java
``` java
/**
 * Tests view command and agenda time range change event. Currently only
 * tentative and will add in more later.
 */
public class ViewCommandTest extends TaskMasterGuiTest {

    private final long DAY = 24 * 60 * 60 * 1000;

    @Test
    public void viewSwitch() {
        
        //Add an additional deadline task to verify the changes in tasklist panel.
        commandBox.runCommand(td.incoming.getAddNonFloatingCommand());

        // View today
        TestTask toBeAdded = td.weekly;
        ArrayList<TaskOccurrence> expectedList = new ArrayList<TaskOccurrence>();
        expectedList.add(toBeAdded.getLastAppendedComponent());
        commandBox.runCommand(toBeAdded.getAddRecurringCommand());
        assertViewSuccess("today", expectedList);
        assertTrue(taskListPanel.isListMatching(td.labDeadline.getLastAppendedComponent(),
                td.essayDeadline.getLastAppendedComponent()));

        // View next week today
        TaskOccurrence updated = toBeAdded.getLastAppendedComponent();
        updated.setStartDate(new TaskDate(updated.getStartDate().getDateInLong() + 7 * DAY));
        updated.setEndDate(new TaskDate(updated.getEndDate().getDateInLong() + 7 * DAY));
        expectedList.set(0, updated);
        assertViewSuccess("next week today", expectedList);
        assertTrue(taskListPanel.isListMatching(td.labDeadline.getLastAppendedComponent(),
                td.essayDeadline.getLastAppendedComponent(),
                td.incoming.getLastAppendedComponent()));
             
    }
    
    @Test
    public void viewUndoRedo() {
        
        //Add an additional deadline task to verify the changes in tasklist panel.
        commandBox.runCommand(td.incoming.getAddNonFloatingCommand());

        // View today
        TestTask toBeAdded = td.none;
        ArrayList<TaskOccurrence> expectedList = new ArrayList<TaskOccurrence>();
        expectedList.add(toBeAdded.getLastAppendedComponent());
        commandBox.runCommand(toBeAdded.getAddRecurringCommand());
        assertViewSuccess("today", expectedList);

        // View next week today
        expectedList.clear();
        assertViewSuccess("next week today", expectedList);
        
        //Verifies undo/redo
        expectedList.add(toBeAdded.getLastAppendedComponent());
        commandBox.runCommand("u");
        assertEquals(MyAgendaUtil.getConvertedTime(new TaskDate("today")).truncatedTo(ChronoUnit.DAYS),
                browser.getMyAgenda().getDisplayedLocalDateTime());
        assertIsAgendaMatching(expectedList);
        assertTrue(taskListPanel.isListMatching(td.labDeadline.getLastAppendedComponent(),
                td.essayDeadline.getLastAppendedComponent()));
        
        expectedList.clear();
        commandBox.runCommand("r");
        assertEquals(MyAgendaUtil.getConvertedTime(new TaskDate("next week today")).truncatedTo(ChronoUnit.DAYS),
                browser.getMyAgenda().getDisplayedLocalDateTime());
        assertIsAgendaMatching(expectedList);
        assertTrue(taskListPanel.isListMatching(td.labDeadline.getLastAppendedComponent(),
                td.essayDeadline.getLastAppendedComponent(),
                td.incoming.getLastAppendedComponent()));
        
             
    }

    public void assertViewSuccess(String date, ArrayList<TaskOccurrence> expectedList) {

        commandBox.runCommand("view " + date);
        assertEquals(MyAgendaUtil.getConvertedTime(new TaskDate(date)).truncatedTo(ChronoUnit.DAYS),
                browser.getMyAgenda().getDisplayedLocalDateTime());
        assertIsAgendaMatching(expectedList);

    }
}
```
###### \java\seedu\taskmaster\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_addNonFloatingUnrecognizableDate_notAllowed() throws Exception {
        String expectedMessage = Messages.MESSAGE_ILLEGAL_DATE_INPUT;
        assertCommandBehavior("add task from not a date to not a date", expectedMessage);
        assertCommandBehavior("add task by not a date", expectedMessage);
    }

    @Test
    public void execute_addNonFloatingIlleagalName_notAllowed() throws Exception {
        String expectedMessage = Name.MESSAGE_NAME_CONSTRAINTS;
        assertCommandBehavior("add #$%^&* from 2am to 3am", expectedMessage);
        assertCommandBehavior("add #$%^&*( by 3am", expectedMessage);
    }

    @Test
    public void execute_addNonFloating_sucessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.nonFloatingFromDateToDate();
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
        assertUndoRedoAble(String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
    }
    
    @Test
    public void execute_addDuplicateTag_sucessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.nonFloatingFromDateToDate();
        toBeAdded.setTags(new UniqueTagList(new Tag("same")));
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded)+" t/same",
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
        assertUndoRedoAble(String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
    }

```
###### \java\seedu\taskmaster\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_addDuplicate_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.adam();
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);

        // setup starting state
        model.addTask(toBeAdded); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded), AddFloatingCommand.MESSAGE_DUPLICATE_TASK,
                expectedTM, expectedTM.getTaskOccurrenceList());
    }

    @Test
    public void execute_addOverlapSlot_allowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = new Task(new Name("Task one"), new UniqueTagList(), new TaskDate("2 oct 2am"),
                new TaskDate("2 oct 1pm"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        Task toBeAddedAfter = new Task(new Name("Task two"), new UniqueTagList(), new TaskDate("2 oct 10am"),
                new TaskDate("2 oct 11am"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);
        expectedTM.addTask(toBeAddedAfter);

        // setup starting state
        model.addTask(toBeAdded); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAddedAfter),
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAddedAfter), expectedTM,
                expectedTM.getTaskOccurrenceList());

    }

    @Test
    public void execute_addDeadlineOverlap_Successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = new Task(new Name("Task one"), new UniqueTagList(), new TaskDate("2 oct 2am"),
                new TaskDate("2 oct 1pm"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        Task toBeAddedAfter = new Task(new Name("Task two"), new UniqueTagList(),
                new TaskDate(TaskDate.DATE_NOT_PRESENT), new TaskDate("2 oct 11am"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);
        expectedTM.addTask(toBeAddedAfter);

        // setup starting state
        model.addTask(toBeAdded); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAddedAfter),
                String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAddedAfter), expectedTM,
                expectedTM.getTaskOccurrenceList());
        assertUndoRedoAble(String.format(AddNonFloatingCommand.MESSAGE_SUCCESS, toBeAddedAfter), expectedTM,
                expectedTM.getTaskOccurrenceList());

    }

    @Test
    public void execute_addIllegalSlot_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = new Task(new Name("Task one"), new UniqueTagList(), new TaskDate("2 oct 6am"),
                new TaskDate("2 oct 5am"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        TaskMaster expectedTM = new TaskMaster();

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded), AddNonFloatingCommand.MESSAGE_ILLEGAL_TIME_SLOT,
                expectedTM, expectedTM.getTaskOccurrenceList());

    }
```
###### \java\seedu\taskmaster\logic\LogicManagerTest.java
``` java
    /**
     * The logic for block command is actually the same as add-non=floating
     * commands.
     */
    @Test
    public void execute_block_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, BlockCommand.MESSAGE_USAGE);
        assertCommandBehavior("block 2am to 3am", expectedMessage);
    }

    @Test
    public void execute_block_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = new Task(new Name(Name.DUMMY_NAME), new UniqueTagList(), new TaskDate("2 oct 2am"),
                new TaskDate("2 oct 1pm"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateBlockCommand(toBeAdded),
                String.format(BlockCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM, expectedTM.getTaskOccurrenceList());
        assertUndoRedoAble(String.format(BlockCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());

    }

    @Test
    public void execute_blockOverlapSlot_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeBlocked = new Task(new Name(Name.DUMMY_NAME), new UniqueTagList(), new TaskDate("2 oct 2am"),
                new TaskDate("2 oct 1pm"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        Task toBeAddedAfter = new Task(new Name(Name.DUMMY_NAME), new UniqueTagList(),
                new TaskDate("2 oct 10am"), new TaskDate("2 oct 11am"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeBlocked);

        // setup starting state
        model.addTask(toBeBlocked); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAddedAfter), BlockCommand.MESSAGE_TIMESLOT_OCCUPIED,
                expectedTM, expectedTM.getTaskOccurrenceList());

    }

    @Test
    public void execute_blockOverlapWithExistingTask_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeBlocked = new Task(new Name("Test Task"), new UniqueTagList(), new TaskDate("2 oct 2am"),
                new TaskDate("2 oct 1pm"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        Task toBeAddedAfter = new Task(new Name(Name.DUMMY_NAME), new UniqueTagList(),
                new TaskDate("2 oct 10am"), new TaskDate("2 oct 11am"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeBlocked);

        // setup starting state
        model.addTask(toBeBlocked); // task already in internal task list

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAddedAfter), BlockCommand.MESSAGE_TIMESLOT_OCCUPIED,
                expectedTM, expectedTM.getTaskOccurrenceList());

    }

    @Test
    public void execute_blockIllegalSlot_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeBlocked = new Task(new Name(Name.DUMMY_NAME), new UniqueTagList(), new TaskDate("2 oct 6am"),
                new TaskDate("2 oct 5am"), RecurringType.NONE, Task.NO_RECURRING_PERIOD);
        TaskMaster expectedTM = new TaskMaster();

        // execute command and verify result
        assertCommandBehavior(helper.generateBlockCommand(toBeBlocked), BlockCommand.MESSAGE_ILLEGAL_TIME_SLOT,
                expectedTM, expectedTM.getTaskOccurrenceList());

    }

    /**
     * Tests for undo/redo commands.
     */
    @Test
    public void execute_undoredoNothing_notAllowed() throws Exception {
        // setup expectations
        TaskMaster expectedTM = new TaskMaster();

        // execute command and verify result
        assertCommandBehavior("u", UndoCommand.MESSAGE_FAIL, expectedTM, expectedTM.getTaskOccurrenceList());

        assertCommandBehavior("r", RedoCommand.MESSAGE_FAIL, expectedTM, expectedTM.getTaskOccurrenceList());
    }

    @Test
    public void execute_undoredo_Successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.adam();
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());

        expectedTM = new TaskMaster();
        assertCommandBehavior("u", UndoCommand.MESSAGE_SUCCESS, expectedTM, expectedTM.getTaskOccurrenceList());

        expectedTM.addTask(toBeAdded);
        assertCommandBehavior("r", String.format(AddFloatingCommand.MESSAGE_SUCCESS, toBeAdded), expectedTM,
                expectedTM.getTaskOccurrenceList());
    }

    @Test
    public void execute_undoredoReachMaxTimes_notAllowed() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        for (int i = 1; i < 5; i++) {
            Task t = helper.generateTask(i);
            logic.execute(helper.generateAddCommand(t));
        }
        for (int i = 0; i < 3; i++) {
            logic.execute("u");
        }

        expectedTM.addTask(helper.generateTask(1));
        assertCommandBehavior("u", UndoCommand.MESSAGE_FAIL, expectedTM, expectedTM.getTaskOccurrenceList());

        for (int i = 0; i < 3; i++) {
            logic.execute("r");
            expectedTM.addTask(helper.generateTask(2 + i));
        }

        assertCommandBehavior("r", RedoCommand.MESSAGE_FAIL, expectedTM, expectedTM.getTaskOccurrenceList());
    }

    @Test
    public void execute_undoInvalidCommand_notAllowed() throws Exception {

        TaskMaster expectedTM = new TaskMaster();
        logic.execute("adds t");
        assertCommandBehavior("u", UndoCommand.MESSAGE_FAIL, expectedTM, expectedTM.getTaskOccurrenceList());

    }

    @Test
    public void execute_undoFailedCommand_notAllowed() throws Exception {

        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        Task toBeAdded = helper.adam();

        expectedTM.addTask(toBeAdded);
        model.addTask(toBeAdded);

        logic.execute(helper.generateAddCommand(toBeAdded));

        assertCommandBehavior("u", UndoCommand.MESSAGE_FAIL, expectedTM, expectedTM.getTaskOccurrenceList());

    }

    /***
     * Tests for ChangeDirectoryCommand
     */
    @Test
    public void execute_changeDirectoryIllegalDirectory_notAllowed() throws Exception {

        TaskMaster expectedTM = new TaskMaster();
        assertCommandBehavior("cd random path", ChangeDirectoryCommand.MESSAGE_CONVENSION_ERROR, expectedTM,
                expectedTM.getTaskOccurrenceList());
    }

    @Test
    public void execute_changeDirectoryWrongFileType_notAllowed() throws Exception {

        TaskMaster expectedTM = new TaskMaster();
        assertCommandBehavior("cd " + saveFolder.getRoot().getPath() + "cdtest.txt",
                ChangeDirectoryCommand.MESSAGE_CONVENSION_ERROR, expectedTM, expectedTM.getTaskOccurrenceList());
    }

    @Test
    public void execute_changeDirectory_Successful() throws Exception {

        TestDataHelper helper = new TestDataHelper();
        TaskMaster expectedTM = new TaskMaster();
        assertCommandBehavior("cd " + saveFolder.getRoot().getPath() + "cdtest.xml",
                String.format(ChangeDirectoryCommand.MESSAGE_SUCCESS, saveFolder.getRoot().getPath() + "cdtest.xml"),
                expectedTM, expectedTM.getTaskOccurrenceList());

        // CD is irreversible
        assertCommandBehavior("u", UndoCommand.MESSAGE_FAIL, expectedTM, expectedTM.getTaskOccurrenceList());

        // Ensure model writes to this file
        expectedTM.addTask(helper.adam());
        logic.execute(helper.generateAddCommand(helper.adam()));
        ReadOnlyTaskMaster retrieved = new StorageManager(saveFolder.getRoot().getPath() + "cdtest.xml",
                saveFolder.getRoot().getPath() + "TempPreferences.json").readTaskList().get();
        assertEquals(expectedTM, new TaskMaster(retrieved));
        assertEquals(model.getTaskMaster(), new TaskMaster(retrieved));

    }
```
###### \java\seedu\taskmaster\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_completeInvalidArgsFormat_errorMessageShown() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE);
        assertIncorrectIndexFormatBehaviorForCommand("done", expectedMessage);
    }

    @Test
    public void execute_completeIndexNotFound_errorMessageShown() throws Exception {
        assertIndexNotFoundBehaviorForCommand("done");
    }

    @Test
    public void execute_complete_removesCorrectTask() throws Exception {
        TestDataHelper helper = new TestDataHelper();

        Task toComplete = helper.adam();
        TaskMaster expectedTM = new TaskMaster();
        expectedTM.addTask(toComplete);
        model.addTask(toComplete);

        assertCommandBehavior("done 1", String.format(CompleteCommand.MESSAGE_COMPLETE_TASK_SUCCESS, toComplete),
                expectedTM, new TaskMaster().getTaskOccurrenceList());
        assertUndoRedoAble(String.format(CompleteCommand.MESSAGE_COMPLETE_TASK_SUCCESS, toComplete), expectedTM,
                new TaskMaster().getTaskOccurrenceList());

    }
```
###### \java\seedu\taskmaster\logic\LogicManagerTest.java
``` java
    @Test
    public void execute_find_invalidDateFormat() throws Exception {
        String expectedMessage = Messages.MESSAGE_ILLEGAL_DATE_INPUT;
        assertCommandBehavior("find from xx to xx", expectedMessage);
        assertCommandBehavior("find by xx", expectedMessage);
    }
    @Test
    public void execute_findByDateTimeBoundary() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla rAnDoM bla bceofeia");
        Task pTarget3 = helper.generateTaskWithName("key key");
        Task p1 = helper.generateTaskWithName("sduauo");
        Task test = helper.nonFloatingByDate();
        Task test2 = helper.nonFloatingFromDateToDate();

        List<Task> fourTasks = helper.generateTasks(pTarget1, p1, pTarget2, pTarget3);
        TaskMaster expectedTM = helper.generateTaskList(fourTasks);
        List<Task> expectedList = helper.generateTasks(test);

        expectedTM.addTask(test);
        expectedTM.addTask(test2);
        helper.addToModel(model, fourTasks);
        model.addTask(test);
        model.addTask(test2);

        List<TaskOccurrence> componentList = helper.buildTaskComponentsFromTaskList(expectedList);

        // find by exact time successful
        assertCommandBehavior("find by 20 oct 11am", Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTM, componentList);
        // find by earlier time boundary lists nothing
        assertCommandBehavior("find by 20 oct 10.59am", Command.getMessageForTaskListShownSummary(0), expectedTM,
                new TaskMaster().getTaskOccurrenceList());
        // find by later time boundary successful
        assertCommandBehavior("find by 20 oct 11.01pm", Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTM, componentList);
    }

    @Test
    public void execute_findFromDateBoundaryToDateBoundary() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla rAnDoM bla bceofeia");
        Task pTarget3 = helper.generateTaskWithName("key key");
        Task p1 = helper.generateTaskWithName("sduauo");
        Task test = helper.nonFloatingFromDateToDate();
        Task test2 = helper.nonFloatingByDate();

        List<Task> fourTasks = helper.generateTasks(pTarget1, p1, pTarget2, pTarget3);
        TaskMaster expectedTM = helper.generateTaskList(fourTasks);
        List<Task> expectedList = helper.generateTasks(test,test2);

        expectedTM.addTask(test);
        expectedTM.addTask(test2);

        helper.addToModel(model, fourTasks);
        model.addTask(test);
        model.addTask(test2);
        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);

        // find by exact boundary successful
        assertCommandBehavior("find from 19 oct 10pm to 20 oct 11am",
                Command.getMessageForTaskListShownSummary(expectedList.size()), expectedTM, expectedComponentList);
        // find by smaller boundary lists nothing
        expectedComponentList.remove(0);
        assertCommandBehavior("find from 19 oct 10.01pm to 20 oct 11am", Command.getMessageForTaskListShownSummary(1),
                expectedTM, expectedComponentList);

        assertCommandBehavior("find from 19 oct 10pm to 20 oct 10.59am", Command.getMessageForTaskListShownSummary(0),
                expectedTM, new TaskMaster().getTaskOccurrenceList());
        // find by lax boundary successful
        expectedComponentList.add(0, test.getLastAppendedComponent());
        assertCommandBehavior("find from 19 oct 9pm to 20 oct 1pm",
                Command.getMessageForTaskListShownSummary(expectedList.size()), expectedTM, expectedComponentList);
    }

    @Test
    public void execute_findFloatingTasksbyType_Successful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla rAnDoM bla bceofeia");
        Task pTarget3 = helper.generateTaskWithName("key key");
        Task p1 = helper.generateTaskWithName("sduauo");
        Task test = helper.nonFloatingFromDateToDate();

        List<Task> threeTasks = helper.generateTasks(pTarget1, pTarget2, pTarget3);
        TaskMaster expectedTM = helper.generateTaskList(threeTasks);
        List<Task> expectedList = helper.generateTasks(pTarget1, pTarget2, pTarget3);

        expectedTM.addTask(test);
        expectedTM.addTask(p1);

        helper.addToModel(model, threeTasks);
        model.addTask(test);
        model.addTask(p1);
        logic.execute("done 5");

        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);

        assertCommandBehavior("find -F", Command.getMessageForTaskListShownSummary(expectedList.size()), expectedTM,
                expectedComponentList);

    }

    @Test
    public void execute_findCompletedTasksbyType_Successful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task test = helper.nonFloatingFromDateToDate();

        TaskMaster expectedTM = new TaskMaster();
        List<Task> expectedList = helper.generateTasks(test);

        expectedTM.addTask(pTarget1);
        expectedTM.addTask(test);

        model.addTask(pTarget1);
        model.addTask(test);

        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);

        logic.execute("done 2");

        assertCommandBehavior("find -C", Command.getMessageForTaskListShownSummary(expectedList.size()), expectedTM,
                expectedComponentList);

    }

    @Test
    public void execute_findbyMultipleConstraints_Successful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task test = helper.nonFloatingFromDateToDate();

        TaskMaster expectedTM = new TaskMaster();
        List<Task> expectedList = helper.generateTasks(test);

        expectedTM.addTask(pTarget1);
        expectedTM.addTask(test);

        model.addTask(pTarget1);
        model.addTask(test);

        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);

        assertCommandBehavior("find non floating from 19 oct 1am to 21 oct 3am",
                Command.getMessageForTaskListShownSummary(expectedList.size()), expectedTM, expectedComponentList);

    }

    @Test
    public void execute_findbyTag_Successful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task test = helper.nonFloatingFromDateToDate();

        TaskMaster expectedTM = new TaskMaster();
        List<Task> expectedList = helper.generateTasks(test);

        expectedTM.addTask(pTarget1);
        expectedTM.addTask(test);

        model.addTask(pTarget1);
        model.addTask(test);

        List<TaskOccurrence> expectedComponentList = helper.buildTaskComponentsFromTaskList(expectedList);

        assertCommandBehavior("find t/tag1", Command.getMessageForTaskListShownSummary(expectedList.size()), expectedTM,
                expectedComponentList);

    }

    /**
     * Tests for view command.
     */
    @Test
    public void execute_view_InvalidInputDate_notAllowed() throws Exception {
        String expectedMessage = Messages.MESSAGE_ILLEGAL_DATE_INPUT;
        assertCommandBehavior("view random input", expectedMessage);
    }

    @Test
    public void execute_view_successful() throws Exception {
        String test = "23 oct 12am";
        TaskDate testDate = new TaskDate(test);
        assertCommandBehavior("view 23 oct 12am",
                String.format(ViewCommand.MESSAGE_UPDATE_AGENDA_SUCCESS, formatter.format(testDate.getDate())));
        assertEquals(testDate, checkDate);
        assertEquals(latestSavedTaskList.getTaskOccurrenceList(), checkList);
        assertEquals(model.getTaskMaster().getTaskOccurrenceList(), checkList);
        
    }
```
###### \java\seedu\taskmaster\testutil\TestTask.java
``` java
    public String getAddFloatingCommand() {
    	this.type = TaskType.FLOATING;
        return getAddCommand();
    }
    
    public String getAddNonFloatingCommand() {
    	this.type = TaskType.NON_FLOATING;
    	return getAddCommand();
    }
    
    public String getAddRecurringCommand(){
    	this.type = TaskType.NON_FLOATING;
        return getAddCommand();
    }
    
    public String getBlockCommand() {
    	this.type = TaskType.NON_FLOATING;
        StringBuilder sb = new StringBuilder();
        sb.append("block ");
        sb.append("from "+ this.getLastAppendedComponent().getStartDate().getInputDate() + " ");
        sb.append("to "+ this.getLastAppendedComponent().getEndDate().getInputDate() + " ");
        this.getTags().getInternalList().stream().forEach(s -> sb.append("t/" + s.tagName + " "));
        return sb.toString();
    }
    
    public boolean equals(TestTask toCompare) {
        return this.isSameStateAs(toCompare);
    }
    
    private String getAddCommand(){
    	StringBuilder sb = new StringBuilder();
        sb.append("add " + this.getName().fullName + " ");
        if(this.type != TaskType.FLOATING){
        	if(this.getLastAppendedComponent().isDeadline()){
            	sb.append("by "+ this.getLastAppendedComponent().getEndDate().getInputDate() + " ");
            }else{
            	sb.append("from "+ this.getLastAppendedComponent().getStartDate().getInputDate() + " ");
            	sb.append("to "+ this.getLastAppendedComponent().getEndDate().getInputDate() + " ");
            }
        	if(this.recurringType!=RecurringType.NONE)
        		sb.append(this.getRecurringType().toString() + " ");
        }
        this.getTags().getInternalList().stream().forEach(s -> sb.append("t/" + s.tagName + " "));
        return sb.toString();       
    }
}
```
###### \java\seedu\taskmaster\testutil\TypicalTestTasks.java
``` java
    /** Non-floating test tasks. */
    public static TestTask labDeadline, tutorialSlot, essayDeadline, concert, movie, project, paper, incoming;

    /** Blocked slots. */
    public static TestTask block1, block2, block3;

    /** Recurring Task. */
    public static TestTask daily, weekly, monthly, yearly, none, block;

    public TypicalTestTasks() {
        try {
            // Floating tasks
            trash = new TaskBuilder().withName("take trash").withTags("notUrgent").build();
            book = new TaskBuilder().withName("read book").withTags("CS2105", "textBook").build();
            homework = new TaskBuilder().withName("do homework").withTags("CS2105").build();
            lecture = new TaskBuilder().withName("read weblecture").build();
            meeting = new TaskBuilder().withName("group meeting").build();
            george = new TaskBuilder().withName("visit George Best").build();
            // Non-floating tasks
            labDeadline = new TaskBuilder().withName("cs lab").withEndDate("18 oct 5pm").build();
            tutorialSlot = new TaskBuilder().withName("cs tutorial").withStartDate("17 oct 1pm")
                    .withEndDate("17 oct 2pm").build();
            essayDeadline = new TaskBuilder().withName("cs essay").withEndDate("19 oct 12am").withTags("urgent")
                    .build();
            concert = new TaskBuilder().withName("concert").withStartDate("17 oct 7pm").withEndDate("17 oct 9pm")
                    .build();
            // Manually added
            hoon = new TaskBuilder().withName("eat with Hoon Meier").build();
            ida = new TaskBuilder().withName("play with Ida Mueller").build();
            project = new TaskBuilder().withName("project discussion").withStartDate("19 oct 4pm")
                    .withEndDate("19 oct 5pm").build();
            paper = new TaskBuilder().withName("cs paper").withEndDate("18 oct 5pm").build();
            block1 = new TaskBuilder().withName("BLOCKED SLOT").withStartDate("20 oct 2pm").withEndDate("20 oct 3pm")
                    .withTags("tag").build();
            incoming = new TaskBuilder().withName("incoming").withEndDate("tomorrow 5pm").build();
            // Exceptions
            // Add non-floating overlapped timeslot
            movie = new TaskBuilder().withName("movie").withStartDate("17 oct 8pm").withEndDate("17 oct 11pm").build();
            // Block overlapped timeslot
            block2 = new TaskBuilder().withName("BLOCKED SLOT").withStartDate("17 oct 8pm").withEndDate("17 oct 11pm")
                    .build();
            // Recurring Type
            daily = new TaskBuilder().withName("Daily Task").withStartDate("7am").withEndDate("8am")
                    .withRecurringType(RecurringType.DAILY).build();
            weekly = new TaskBuilder().withName("Weekly Task").withStartDate("6am").withEndDate("7am")
                    .withRecurringType(RecurringType.WEEKLY).build();
            monthly = new TaskBuilder().withName("Monthly Task").withStartDate("5am").withEndDate("6am")
                    .withRecurringType(RecurringType.MONTHLY).build();
            yearly = new TaskBuilder().withName("Yearly Task").withStartDate("3am").withEndDate("5am")
                    .withRecurringType(RecurringType.YEARLY).build();
            none = new TaskBuilder().withName("Normal Task").withStartDate("1am").withEndDate("3am")
                    .withRecurringType(RecurringType.NONE).build();
            block = new TaskBuilder().withName("BLOCKED SLOT").withStartDate("8am").withEndDate("9am")
                    .withRecurringType(RecurringType.NONE).build();
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

```
###### \java\seedu\taskmaster\testutil\TypicalTestTasks.java
``` java
    public TestTask[] getTypicalTasksWithRecurringOnes() {
        return new TestTask[] { trash, tutorialSlot, essayDeadline, concert, yearly, monthly, weekly, daily, none };
    }

```
